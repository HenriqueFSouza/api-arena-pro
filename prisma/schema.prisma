generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Profile {
  id           String @id @default(uuid())
  name         String
  email        String @unique
  passwordHash String @map("password_hash")
  phone        String

  // Relationships
  categories ProductCategory[]
  products   Product[]
  clients    ProfileClient[]
  orders     Order[]

  createdAt    DateTime       @default(now()) @map("created_at")
  updatedAt    DateTime       @updatedAt @map("updated_at")
  CashRegister CashRegister[]
  Expense      Expense[]
  Stock        Stock[]

  @@map("profile")
}

model ProductCategory {
  id          String  @id @default(uuid())
  name        String
  description String?

  // Relationships
  owner    Profile   @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId  String    @map("owner_id")
  products Product[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("product_categories")
}

model Product {
  id          String  @id @default(uuid())
  name        String
  description String?
  price       Decimal @db.Decimal(10, 2)
  quantity    Int?    @map("quantity")
  imageUrl    String? @map("image_url")

  // Relationships
  category   ProductCategory @relation(fields: [categoryId], references: [id])
  categoryId String          @map("category_id")
  owner      Profile         @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId    String          @map("owner_id")
  orderItems OrderItem[]

  createdAt    DateTime       @default(now()) @map("created_at")
  updatedAt    DateTime       @updatedAt @map("updated_at")
  stockProduct StockProduct[]

  @@map("products")
}

model Client {
  id    String @id @default(uuid())
  name  String
  phone String @unique

  // Relationships
  profiles ProfileClient[]
  orders   OrderClient[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("clients")
}

model ProfileClient {
  id String @id @default(uuid())

  // Relationships
  profile   Profile @relation(fields: [profileId], references: [id], onDelete: Cascade)
  profileId String  @map("profile_id")
  client    Client  @relation(fields: [clientId], references: [id], onDelete: Cascade)
  clientId  String  @map("client_id")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([profileId, clientId])
  @@map("profile_clients")
}

enum OrderStatus {
  OPEN
  CLOSED
  ARCHIVED
}

enum PaymentMethod {
  CASH
  CARD
  PIX
}

enum PaymentStatus {
  PENDING
  COMPLETED
  CANCELLED
}

model Discount {
  id     String  @id @default(uuid())
  value  Decimal @db.Decimal(10, 2)
  reason String?

  // Relationships
  order   Order  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId String @map("order_id")

  createdAt DateTime @default(now()) @map("created_at")

  @@map("discounts")
}

model Order {
  id     String      @id @default(uuid())
  status OrderStatus @default(OPEN)
  note   String?

  // Relationships
  owner   Profile @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId String  @map("owner_id")

  clientsData Json?

  // Order can be split between multiple clients
  clients   OrderClient[]
  items     OrderItem[]
  payments  Payment[]
  discounts Discount[]

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("orders")
}

model OrderClient {
  id String @id @default(uuid())

  // Optional note for this client's part of the order
  note String?

  // Relationships
  order    Order       @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId  String      @map("order_id")
  client   Client      @relation(fields: [clientId], references: [id])
  clientId String      @map("client_id")
  items    OrderItem[]
  payments Payment[]

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@unique([orderId, clientId])
  @@map("order_clients")
}

model OrderItem {
  id       String  @id @default(uuid())
  quantity Int
  price    Decimal @db.Decimal(10, 2)
  note     String?

  // Relationships
  order     Order    @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId   String   @map("order_id")
  product   Product? @relation(fields: [productId], references: [id])
  productId String?  @map("product_id")

  // Optional relationship to specific client in split orders
  orderClient   OrderClient? @relation(fields: [orderClientId], references: [id])
  orderClientId String?      @map("order_client_id")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("order_items")
}

model Payment {
  id     String        @id @default(uuid())
  amount Decimal       @db.Decimal(10, 2)
  method PaymentMethod
  status PaymentStatus @default(PENDING)
  note   String?

  // Relationships
  order   Order  @relation(fields: [orderId], references: [id])
  orderId String @map("order_id")

  // Optional relationship to specific client in split orders
  orderClient   OrderClient? @relation(fields: [orderClientId], references: [id])
  orderClientId String?      @map("order_client_id")

  // Timestamps
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("payments")
}

model CashRegister {
  id String @id @default(uuid())

  openedAmount   Float
  expectedAmount Float
  closedAmount   Float?

  owner   Profile @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId String  @map("owner_id")

  registeredPayments Json // Array of { paymentMethod: 'CASH' | 'CARD' | 'PIX', amount: number }
  createdAt          DateTime      @default(now()) @map("created_at")
  closedAt           DateTime?     @map("closed_at")
  transactions       Transaction[]

  @@map("cash_register")
}

model Transaction {
  id String @id @default(uuid())

  cashRegister   CashRegister @relation(fields: [cashRegisterId], references: [id], onDelete: Cascade)
  cashRegisterId String       @map("cash_register_id")

  originId      String?        @map("origin_id") // Allowed to be null for increment transactions
  originType    String         @map("origin_type") // 'PAYMENT' | 'EXPENSE' | 'INCREMENT'
  paymentMethod PaymentMethod? @map("payment_method") // Only used for payment transactions

  amount    Float?
  reason    String?
  createdAt DateTime @default(now()) @map("created_at")

  @@map("transactions")
}

enum UnitMeasure {
  UNIT
  KILOGRAM
  LITER
}

enum StockHistoryType {
  INCOMING
  OUTGOING
  ADJUSTMENT
  INVENTORY
}

model Stock {
  id          String      @id @default(uuid())
  name        String
  quantity    Float
  unitMeasure UnitMeasure @map("unit_measure")
  unitPrice   Decimal     @map("unit_price") @db.Decimal(10, 2)
  minStock    Float?      @map("min_stock")

  totalAmountSpent       Float? @map("total_amount_spent")
  totalQuantityPurchased Float? @map("total_quantity_purchased")

  // Relationships
  expense   Expense @relation(fields: [expenseId], references: [id])
  expenseId String  @map("expense_id")
  owner     Profile @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId   String  @map("owner_id")

  createdAt    DateTime       @default(now()) @map("created_at")
  updatedAt    DateTime       @updatedAt @map("updated_at")
  stockProduct StockProduct[]
  stockHistory StockHistory[]

  @@map("stock")
}

model StockProduct {
  id String @id @default(uuid())

  quantity Float

  stock     Stock   @relation(fields: [stockId], references: [id], onDelete: Cascade)
  stockId   String  @map("stock_id")
  product   Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  productId String  @map("product_id")

  @@map("stock_products")
}

model StockHistory {
  id String @id @default(uuid())

  type        StockHistoryType @map("type")
  description String?

  initialQuantity Float @default(0)
  finalQuantity   Float

  totalPrice Float?
  unitPrice  Float?

  stock   Stock  @relation(fields: [stockId], references: [id], onDelete: Cascade)
  stockId String @map("stock_id")

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("stock_history")
}

model Expense {
  id String @id @default(uuid())

  name    String
  owner   Profile? @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId String?  @map("owner_id")
  stocks  Stock[]

  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  @@map("expenses")
}
